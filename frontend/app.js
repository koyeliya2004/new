const translations = {
  en: {
    appTitle: "Rooftop Rainwater Harvesting Planner",
    appSubtitle: "On-spot assessment for rooftop rainwater harvesting (RTRWH) and artificial recharge.",
    languageLabel: "Language",
    assessmentTitle: "Quick Assessment",
    nameLabel: "Name",
    locationLabel: "Location",
    dwellersLabel: "Number of dwellers",
    roofAreaLabel: "Roof area (m²)",
    openSpaceLabel: "Available open space (m²)",
    rainfallLabel: "Annual rainfall (mm)",
    mapHint: "Drop a pin to auto-detect roof area (CV model)",
    pinLabel: "Pin coordinates",
    estimateButton: "Estimate roof area",
    generateButton: "Generate assessment",
    resultsTitle: "Personalized Outputs",
    aquiferTitle: "Principal aquifer",
    depthTitle: "Depth to groundwater",
    rainfallTitle: "Local rainfall",
    runoffTitle: "Runoff generation",
    structureTitle: "Suggested RTRWH/AR structure",
    dimensionTitle: "Recommended dimensions",
    costTitle: "Cost estimate & benefit",
    forecastTitle: "Next 7 days forecast",
    digitalTwinTitle: "Geological Digital Twin",
    soilLabel: "Soil zone",
    aquiferLabel: "Aquifer storage",
    bedrockLabel: "Bedrock",
    communityTitle: "Water Credit Leaderboard",
    creditsLabel: "Your water credits",
    addCredits: "Add to neighborhood score",
    neighborhoodLabel: "Neighborhood recharge score",
    arTitle: "AR Placement Preview",
    arHint: "Visualize the proposed structure size in your yard before installation.",
    implementationTitle: "Implementation Loop",
    marketplaceTitle: "Marketplace integration",
    blueprintTitle: "DIY Smart Blueprint",
    blueprintText: "Download a localized bill of materials and layout.",
    downloadBlueprint: "Download blueprint (PDF)",
    policyTitle: "Policy & subsidy tracker",
    footerNote:
      "Calculations are indicative and based on CGWB guidance. Verify with local engineers before construction.",
  },
  hi: {
    appTitle: "छत वर्षा जल संचयन योजना",
    appSubtitle: "रूफटॉप रेनवॉटर हार्वेस्टिंग और कृत्रिम रिचार्ज का त्वरित आकलन।",
    languageLabel: "भाषा",
    assessmentTitle: "त्वरित आकलन",
    nameLabel: "नाम",
    locationLabel: "स्थान",
    dwellersLabel: "परिवार के सदस्य",
    roofAreaLabel: "छत का क्षेत्रफल (m²)",
    openSpaceLabel: "खुला स्थान (m²)",
    rainfallLabel: "वार्षिक वर्षा (mm)",
    mapHint: "पिन ड्रॉप कर छत क्षेत्र का अनुमान लगाएं (CV मॉडल)",
    pinLabel: "पिन निर्देशांक",
    estimateButton: "छत क्षेत्र अनुमान",
    generateButton: "आकलन तैयार करें",
    resultsTitle: "व्यक्तिगत परिणाम",
    aquiferTitle: "मुख्य जलभृत",
    depthTitle: "भूजल गहराई",
    rainfallTitle: "स्थानीय वर्षा",
    runoffTitle: "रनऑफ क्षमता",
    structureTitle: "अनुशंसित संरचना",
    dimensionTitle: "अनुशंसित आयाम",
    costTitle: "लागत और लाभ",
    forecastTitle: "अगले 7 दिन का अनुमान",
    digitalTwinTitle: "जियोलॉजिकल डिजिटल ट्विन",
    soilLabel: "मृदा क्षेत्र",
    aquiferLabel: "जलभृत भंडारण",
    bedrockLabel: "बेडरॉक",
    communityTitle: "वॉटर क्रेडिट लीडरबोर्ड",
    creditsLabel: "आपके क्रेडिट",
    addCredits: "समुदाय स्कोर में जोड़ें",
    neighborhoodLabel: "समुदाय रिचार्ज स्कोर",
    arTitle: "एआर प्लेसमेंट पूर्वावलोकन",
    arHint: "अपने आंगन में संरचना का आकार देखें।",
    implementationTitle: "इम्प्लीमेंटेशन लूप",
    marketplaceTitle: "मार्केटप्लेस एकीकरण",
    blueprintTitle: "DIY स्मार्ट ब्लूप्रिंट",
    blueprintText: "स्थानीय सामग्री सूची डाउनलोड करें।",
    downloadBlueprint: "ब्लूप्रिंट डाउनलोड करें",
    policyTitle: "नीति और सब्सिडी",
    footerNote: "गणनाएं संकेतात्मक हैं। निर्माण से पहले विशेषज्ञ से पुष्टि करें।",
  },
  bn: {
    appTitle: "ছাদ বৃষ্টির জল সংরক্ষণ পরিকল্পনা",
    appSubtitle: "ছাদ ভিত্তিক রেনওয়াটার হার্ভেস্টিং ও কৃত্রিম রিচার্জের দ্রুত মূল্যায়ন।",
    languageLabel: "ভাষা",
    assessmentTitle: "দ্রুত মূল্যায়ন",
    nameLabel: "নাম",
    locationLabel: "অবস্থান",
    dwellersLabel: "পরিবারের সদস্য",
    roofAreaLabel: "ছাদের ক্ষেত্রফল (m²)",
    openSpaceLabel: "খোলা জায়গা (m²)",
    rainfallLabel: "বার্ষিক বৃষ্টিপাত (mm)",
    mapHint: "পিন ফেলে ছাদ ক্ষেত্র অনুমান করুন (CV মডেল)",
    pinLabel: "পিন অবস্থান",
    estimateButton: "ছাদ ক্ষেত্র অনুমান",
    generateButton: "মূল্যায়ন করুন",
    resultsTitle: "ব্যক্তিগত ফলাফল",
    aquiferTitle: "প্রধান জলভান্ডার",
    depthTitle: "ভূগর্ভস্থ জলস্তর",
    rainfallTitle: "স্থানীয় বৃষ্টিপাত",
    runoffTitle: "রানঅফ ক্ষমতা",
    structureTitle: "প্রস্তাবিত কাঠামো",
    dimensionTitle: "মাত্রা",
    costTitle: "খরচ ও লাভ",
    forecastTitle: "পরবর্তী ৭ দিনের পূর্বাভাস",
    digitalTwinTitle: "জিওলজিকাল ডিজিটাল টুইন",
    soilLabel: "মাটি স্তর",
    aquiferLabel: "জলভান্ডার",
    bedrockLabel: "বেডরক",
    communityTitle: "ওয়াটার ক্রেডিট লিডারবোর্ড",
    creditsLabel: "আপনার ক্রেডিট",
    addCredits: "কমিউনিটি স্কোরে যোগ করুন",
    neighborhoodLabel: "কমিউনিটি রিচার্জ স্কোর",
    arTitle: "এআর প্রিভিউ",
    arHint: "নিজের উঠোনে কাঠামোর আকার দেখুন।",
    implementationTitle: "ইমপ্লিমেন্টেশন লুপ",
    marketplaceTitle: "মার্কেটপ্লেস ইন্টিগ্রেশন",
    blueprintTitle: "DIY ব্লুপ্রিন্ট",
    blueprintText: "স্থানীয় উপকরণ তালিকা ডাউনলোড করুন।",
    downloadBlueprint: "ব্লুপ্রিন্ট ডাউনলোড",
    policyTitle: "নীতি ও ভর্তুকি",
    footerNote: "গণনা নির্দেশনামূলক। নির্মাণের আগে বিশেষজ্ঞের সাথে নিশ্চিত করুন।",
  },
};

// Base URL for the Flask backend.
// - Local development: defaults to http://localhost:5000
// - Deployed: set BACKEND_URL in a meta tag or window variable, or update this constant
//   e.g. const BASE_URL = "https://your-app.onrender.com";
const BASE_URL = window.BACKEND_URL
  || (window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1"
      ? "http://localhost:5000"
      : "");
const API_BASE = BASE_URL;

/**
 * Call the Flask API. Returns parsed JSON on success or null on any network/HTTP error,
 * allowing the app to continue with local calculations.
 */
const apiFetch = async (path, method = "GET", body = null) => {
  try {
    const opts = { method, headers: { "Content-Type": "application/json" } };
    if (body) opts.body = JSON.stringify(body);
    const res = await fetch(`${API_BASE}${path}`, opts);
    if (res.ok) return res.json();
  } catch {
    // Backend not available — local fallback will be used
  }
  return null;
};

const form = document.getElementById("assessment-form");
const mapHint = document.getElementById("map-hint");
const roofAreaInput = document.getElementById("roof-area");
const openSpaceInput = document.getElementById("open-space");
const rainfallInput = document.getElementById("rainfall");
const locationInput = document.getElementById("location");
const pinInput = document.getElementById("pin");
const languageSelect = document.getElementById("language");
const addCreditsButton = document.getElementById("add-credits");
const blueprintButton = document.getElementById("download-blueprint");
const arStructure = document.getElementById("ar-structure");

let obstructionFactor = 0.05;

const storageKey = "rtrwhNeighborhoodScore";
const baseScore = Number.parseInt(localStorage.getItem(storageKey) || "12400", 10);
let neighborhoodScore = Number.isNaN(baseScore) ? 12400 : baseScore;

document.getElementById("neighborhood-score").textContent = neighborhoodScore.toLocaleString();

const lookupSets = {
  aquifers: ["Alluvium (sand & gravel)", "Basalt", "Granite gneiss", "Laterite"],
  policies: [
    "Check state incentives: 25% subsidy on recharge pits.",
    "Property tax rebate for rainwater harvesting installations.",
    "CGWB advisory: priority for groundwater stressed wards.",
    "District scheme: ₹15,000 assistance for recharge shafts.",
  ],
};

const hashSeed = (value) =>
  value
    .split("")
    .reduce((acc, char) => acc + char.charCodeAt(0), 0);

const pickFrom = (list, seed) => list[seed % list.length];

const formatLiters = (value) => `${Math.round(value).toLocaleString()} liters`;

const formatMeters = (value) => `${value.toFixed(1)} m`;

const deriveRainfall = (location) => {
  if (!location) {
    return 1100;
  }
  const seed = hashSeed(location);
  return 700 + (seed % 700);
};

const deriveForecastRainfall = (location) => {
  const seed = hashSeed(location || "forecast");
  return 15 + (seed % 45);
};

const deriveGroundwaterDepth = (location) => {
  const seed = hashSeed(location || "depth");
  const low = 8 + (seed % 6);
  const high = low + 6;
  return `${low}-${high} m below ground level`;
};

const deriveDigitalTwin = (location) => {
  const seed = hashSeed(location || "twin");
  return 25 + (seed % 40);
};

const estimateRoofAreaFromPin = (pinValue, locationValue) => {
  const seed = hashSeed(pinValue || locationValue || "pin");
  const estimatedArea = 80 + (seed % 120);
  const obstruction = 0.04 + ((seed % 12) / 100);
  return { estimatedArea, obstruction };
};

const decideStructure = (openSpace) => {
  if (openSpace >= 25) {
    return "Recharge pit";
  }
  if (openSpace >= 12) {
    return "Recharge trench";
  }
  return "Recharge shaft";
};

const calculateDimensions = (structure, volume) => {
  if (structure === "Recharge pit") {
    const depth = 2;
    const side = Math.sqrt(volume / depth);
    return `${formatMeters(side)} × ${formatMeters(side)} × ${formatMeters(depth)}`;
  }
  if (structure === "Recharge trench") {
    const depth = 1.5;
    const width = 1.2;
    const length = volume / (depth * width);
    return `${formatMeters(length)} × ${formatMeters(width)} × ${formatMeters(depth)}`;
  }
  const radius = 0.6;
  const depth = volume / (Math.PI * radius * radius);
  return `${formatMeters(depth)} depth • ${formatMeters(radius * 2)} diameter`;
};

const calculateCost = (structure, roofArea) => {
  const base = structure === "Recharge pit" ? 12000 : structure === "Recharge trench" ? 15000 : 18000;
  const filterCost = roofArea * 250;
  return base + filterCost;
};

const updateARPreview = (structure, volume) => {
  const size = Math.min(120, Math.max(40, volume * 15));
  arStructure.style.width = `${size}px`;
  arStructure.style.height = `${structure === "Recharge shaft" ? size * 0.6 : size}px`;
  arStructure.style.borderRadius = structure === "Recharge shaft" ? "50%" : "8px";
};

const updateDashboard = (results) => {
  document.getElementById("aquifer").textContent = results.aquifer;
  document.getElementById("groundwater").textContent = results.depth;
  document.getElementById("rainfall-output").textContent = `${results.rainfall.toLocaleString()} mm annually`;
  document.getElementById("runoff").textContent = `${formatLiters(results.runoff)} / year`;
  document.getElementById("structure").textContent = results.structure;
  document.getElementById("dimensions").textContent = results.dimensions;
  document.getElementById("cost").textContent = `₹${results.cost.toLocaleString()} • Payback in ${results.payback} seasons`;
  document.getElementById("forecast").textContent = `Potential harvest: ${formatLiters(results.forecast)}`;
  document.getElementById("credits").textContent = results.credits.toLocaleString();
  document.getElementById("twin-depth").textContent = `Available void: ${results.twin}%`;
  document.getElementById("policy").textContent = results.policy;
  updateARPreview(results.structure, results.rechargeVolume);
};

const updateImpact = (credits) => {
  const totalLiters = credits * 100 + neighborhoodScore * 10;
  const pools = Math.max(1, Math.round(totalLiters / 2500000));
  document.getElementById("impact").textContent = `You and 40 neighbors have recharged enough to fill ${pools} Olympic pools.`;
};

const generateResults = async () => {
  const name = document.getElementById("name").value.trim();
  const location = locationInput.value.trim();
  const dwellers = Number.parseInt(document.getElementById("dwellers").value, 10) || 1;
  const roofArea = Number.parseFloat(roofAreaInput.value);
  const openSpace = Number.parseFloat(openSpaceInput.value);
  const rainfallOverride = rainfallInput.value ? Number.parseInt(rainfallInput.value, 10) : null;

  // --- Try backend APIs first, fall back to local calculations ---
  const [calcData, recommendData, costData] = await Promise.all([
    apiFetch("/calculate", "POST", {
      roofArea,
      location,
      dwellers,
      ...(rainfallOverride ? { rainfall: rainfallOverride } : {}),
    }),
    apiFetch("/recommend", "POST", {
      openSpace,
      runoff: roofArea * (rainfallOverride || deriveRainfall(location)) * 0.8,
    }),
    apiFetch("/cost", "POST", {
      structure: decideStructure(openSpace),
      runoff: roofArea * (rainfallOverride || deriveRainfall(location)) * 0.8,
    }),
  ]);

  // Resolved values — backend wins, local logic as fallback
  const rainfall = calcData ? calcData.annualRainfallMm : (rainfallOverride || deriveRainfall(location));
  const runoffCoefficient = 0.8;
  const runoff = calcData ? calcData.runoffLiters : roofArea * rainfall * runoffCoefficient;
  const aquifer = calcData ? calcData.aquifer : pickFrom(lookupSets.aquifers, hashSeed(location));
  const depth = calcData ? calcData.groundwaterDepth : deriveGroundwaterDepth(location);
  const policy = calcData ? calcData.policy : pickFrom(lookupSets.policies, hashSeed(location + "policy"));

  const structure = recommendData ? recommendData.structure : decideStructure(openSpace);
  const rechargeVolume = recommendData ? recommendData.rechargeVolumeM3 : Math.max(1, runoff / 1000 * 0.3);
  const dimensions = recommendData ? recommendData.dimensions : calculateDimensions(structure, rechargeVolume);

  const cost = costData ? costData.costRs : calculateCost(structure, roofArea);
  const annualSavings = costData ? costData.annualSavingsRs : Math.round(runoff * 0.05);
  const payback = costData ? costData.paybackYears : (cost / (runoff / 1000)).toFixed(1);

  const forecastRain = deriveForecastRainfall(location);
  const forecast = roofArea * forecastRain * runoffCoefficient;
  const credits = Math.round(runoff / 100);
  const twin = deriveDigitalTwin(location);

  updateDashboard({
    name,
    dwellers,
    roofArea,
    openSpace,
    rainfall,
    aquifer,
    depth,
    runoff,
    structure,
    rechargeVolume,
    dimensions,
    cost,
    forecast,
    payback,
    credits,
    twin,
    policy,
  });

  updateImpact(credits);
};

const applyTranslations = (lang) => {
  const dictionary = translations[lang] || translations.en;
  document.querySelectorAll("[data-i18n]").forEach((node) => {
    const key = node.dataset.i18n;
    if (dictionary[key]) {
      node.textContent = dictionary[key];
    }
  });
};

languageSelect.addEventListener("change", (event) => {
  applyTranslations(event.target.value);
});

form.addEventListener("submit", (event) => {
  event.preventDefault();
  generateResults();
});

document.getElementById("estimate-roof").addEventListener("click", async () => {
  const { estimatedArea, obstruction } = estimateRoofAreaFromPin(pinInput.value, locationInput.value);
  obstructionFactor = obstruction;
  roofAreaInput.value = estimatedArea.toFixed(1);
  mapHint.textContent = `Estimated roof area: ${estimatedArea.toFixed(0)} m² • Obstructions ${(obstruction * 100).toFixed(0)}%`;
  if (!rainfallInput.value) {
    const rainfallData = await apiFetch(`/rainfall?city=${encodeURIComponent(locationInput.value)}`);
    rainfallInput.value = rainfallData ? rainfallData.annualRainfallMm : deriveRainfall(locationInput.value);
  }
});

addCreditsButton.addEventListener("click", () => {
  const credits = Number.parseInt(document.getElementById("credits").textContent.replace(/,/g, ""), 10);
  if (Number.isNaN(credits)) {
    return;
  }
  neighborhoodScore += credits;
  localStorage.setItem(storageKey, neighborhoodScore.toString());
  document.getElementById("neighborhood-score").textContent = neighborhoodScore.toLocaleString();
  updateImpact(credits);
});

blueprintButton.addEventListener("click", () => {
  const structure = document.getElementById("structure").textContent;
  const dimensions = document.getElementById("dimensions").textContent;
  const cost = document.getElementById("cost").textContent;
  const runoff = document.getElementById("runoff").textContent;

  const content = `RTRWH Blueprint\n\nStructure: ${structure}\nDimensions: ${dimensions}\nRunoff Capacity: ${runoff}\nEstimated Cost: ${cost}\n\nBill of Materials\n- PVC downpipe (4")\n- Leaf filter unit\n- Sand & gravel media\n- Geotextile liner\n- Masonry bricks & cement\n\nContact verified vendors for installation.`;

  const blob = new Blob([content], { type: "application/pdf" });
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.href = url;
  link.download = "RTRWH-Blueprint.pdf";
  document.body.appendChild(link);
  link.click();
  link.remove();
  URL.revokeObjectURL(url);
});

const loadLeaderboard = async () => {
  const data = await apiFetch("/leaderboard");
  if (!data) return;
  const tbody = document.getElementById("leaderboard-rows");
  if (tbody) {
    tbody.innerHTML = data.leaderboard
      .map(
        (e) =>
          `<tr><td>${e.rank}</td><td>${e.name}</td><td>${e.city}</td><td>${e.credits.toLocaleString()}</td><td>${e.litersRecharged.toLocaleString()}</td></tr>`
      )
      .join("");
  }
  const poolsEl = document.getElementById("community-pools");
  if (poolsEl) {
    poolsEl.textContent = `Combined community impact: ${data.totalLitersRecharged.toLocaleString()} liters recharged (${data.olympicPoolsEquivalent} Olympic pools).`;
  }
};

const loadVendors = async () => {
  const data = await apiFetch("/vendors");
  if (!data) return;
  const vendorList = document.getElementById("vendors");
  if (vendorList) {
    vendorList.innerHTML = data.vendors
      .map((v) => `<li>${v.name} &bull; ⭐${v.rating} &bull; ${v.city}</li>`)
      .join("");
  }
};

applyTranslations("en");
generateResults();
loadLeaderboard();
loadVendors();
